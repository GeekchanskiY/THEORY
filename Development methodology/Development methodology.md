
[[CI&CD Pipelines]]

The development methodology **consists of multiple sequential phases in a project lifecycle, with some phases being optional, and the order of phases being dependent on the project being undertaken**.

## TDD
Test-driven development (TDD) is a software development methodology in which developers write tests for their code before they write the code itself. The goal of TDD is to ensure that the code is correct and meets the requirements of the project. TDD follows a specific workflow:
1. Write a test: The developer writes a test that defines the desired behavior of the code. 
2. Run the test: The test is run to ensure that it fails, as the code it is testing does not yet exist. 
3. Write the code: The developer writes the code to make the test pass. 
4. Run the tests: The tests are run again to ensure that the code is correct and meets the requirements. 
5. Refactor: The developer can make changes to the code to improve its design or maintainability, as long as the tests continue to pass. 
TDD can help to ensure that code is correct, maintainable, and of high quality. It can also help to prevent defects and reduce the time and effort required to develop and maintain software. However, it does require a significant investment of time and effort upfront, and it may not be suitable for all projects.

## DDD
Domain-driven design (DDD) is a software development approach that focuses on modeling the business domain of a system. It aims to create a shared understanding of the domain between developers and domain experts and to use that understanding to guide the design and development of the system. DDD follows a few key principles:
1. The model should reflect the domain: The design of the system should be based on a rich and accurate model of the business domain, rather than on the technical details of the system. 
2. The model should be expressed in a shared language: The model should be expressed in a language that is understood by both developers and domain experts, to ensure a shared understanding of the domain. 
3. The model should guide the design: The model should be used to guide the design of the system, rather than the other way around. 
4. The model should be iterative: The model should be developed and refined iteratively, through a process of collaboration and feedback between developers and domain experts.
DDD can be useful for developing complex systems in which the business domain is a key driver of the design. It can help to ensure that the system accurately reflects the needs and requirements of the business and is easy for domain experts to understand and use. However, it can require a significant investment of time and effort, and it may not be suitable for all projects.

## Agile
Based on their combined experience of developing software and helping others do that, the authors of the manifesto declared that they valued:

- _**Individuals and interactions** over processes and tools_
- _**Working software** over comprehensive documentation_
- _**Customer collaboration** over contract negotiation_
- _**Responding to change** over following a plan_

That is to say, while both sides have value and the items on the right should be considered, the authors felt that the items on the left should have more influence on how people approach their work.

The _Manifesto for Agile Software Development_ is based on twelve principles:

1. Customer satisfaction by early and continuous delivery of valuable software.
2. Welcome changing requirements, even in late development.
3. Deliver working software frequently (weeks rather than months).
4. Close, daily cooperation between business people and developers.
5. Projects are built around motivated individuals, who should be trusted.
6. Face-to-face conversation is the best form of communication (co-location).
7. Working software is the primary measure of progress.
8. Sustainable development, able to maintain a constant pace.
9. Continuous attention to technical excellence and good design.
10. Simplicity—the art of maximizing the amount of work not done—is essential.
11. Best architectures, requirements, and designs emerge from self-organizing teams.
12. Regularly, the team reflects on how to become more effective, and adjusts accordingly.

### How to setup scrum